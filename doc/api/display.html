<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Doodle.js - API: doodle.createDisplay</title>
<link href="./style/reset.css" rel="stylesheet" type="text/css">
<link href="./style/main.css" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono&subset=latin" rel="stylesheet" type="text/css">
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
<script type="text/javascript" src="./style/main.js"></script>
</head>
<body>

<nav>
<ul>
<li>ColorFilter</li>
<li>Display</li>
<li>ElementNode</li>
<li>Emitter</li>
<li>Event</li>
<li>FontStyle</li>
<li>FontVariant</li>
<li>FontWeight</li>
<li>GradientType</li>
<li>Graphics</li>
<li>Image</li>
<li>Keyboard</li>
<li>KeyboardEvent</li>
<li>Layer</li>
<li>LineCap</li>
<li>LineJoin</li>
<li>Matrix</li>
<li>MouseEvent</li>
<li>Node</li>
<li>Pattern</li>
<li>Point</li>
<li>Rectangle</li>
<li>Sprite</li>
<li>Text</li>
<li>TextAlign</li>
<li>TextBaseline</li>
<li>TextEvent</li>
<li>TouchEvent</li>
<li>UIEvent</li>
<li>utils</li>
<li>utils.debug</li></ul>
</nav>
<div class="main">
<h1>doodle.createDisplay</h1>

<section>
<h2>Description:</h2>
<dl>
<dt><dfn>Display</dfn> (element:HTMLElement, options:object) :Display</dt>
<dd>
<p></p>
<details>

<h3>Inherits</h3>
<ol>
<li>ElementNode</li>
<li>Node</li>
<li>Emitter</li>
<li>Object</li>
</ol>

<h3>Parameters</h3>
<ol>
<li>element:HTMLElement &#8211; <span class='param_annotation'>[optional]</span> </li>
<li>options:object &#8211; <span class='param_annotation'>[optional]</span> </li>
</ol>

<h3>Returns</h3>
<ul>
<li>Display &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; Must be a block style element.</li>
<li>SyntaxError &#8211; </li>
</ul>

<h3>Examples</h3>
<ul>
<li>
<samp>
var display = doodle.createDisplay;<br/> display.width = 400;
</samp>
</li>
<li>
<samp>
var display = doodle.createDisplay(function () {<br/> &nbsp; this.width = 400;<br/> });
</samp>
</li>
</ul>


</details>
</dd>
</dl>
</section>
<section>
<h2>Properties</h2>
<dl>
<dt><dfn>parent</dfn> :null</dt>
<dd>
<p>A Display has no parent.</p>
<details>



<h3>Returns</h3>
<ul>
<li>null &#8211; </li>
</ul>






</details>
</dd>
<dt><dfn>allChildren</dfn> :Array</dt>
<dd>
<p>All descendants of the display, in scene graph order.</p>
<details>



<h3>Returns</h3>
<ul>
<li>Array &#8211; [read-only]</li>
</ul>






</details>
</dd>
<dt><dfn>debug.boundingBox</dfn> :string</dt>
<dd>
<p>Color of the bounding box outline for nodes on the display. Display a particular node's bounds with node.debug.boundingBox = true</p>
<details>



<h3>Returns</h3>
<ul>
<li>string &#8211; </li>
</ul>






</details>
</dd>
<dt><dfn>frameRate</dfn> :number|false</dt>
<dd>
<p>Determines the interval to dispatch the event type Event.ENTER_FRAME. This event is dispatched simultaneously to all display objects listenting for this event. It does not go through a "capture phase" and is dispatched directly to the target, whether the target is on the display list or not.</p>
<details>



<h3>Returns</h3>
<ul>
<li>number|false &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
<li>RangeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>root</dfn> :Display</dt>
<dd>
<p>Display always returns itself as root.</p>
<details>



<h3>Returns</h3>
<ul>
<li>Display &#8211; </li>
</ul>






</details>
</dd>
<dt><dfn>height</dfn> :number</dt>
<dd>
<p>Display height. Setting this affects all it's children layers.</p>
<details>



<h3>Returns</h3>
<ul>
<li>number &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>width</dfn> :number</dt>
<dd>
<p>Display width. Setting this affects all it's children layers.</p>
<details>



<h3>Returns</h3>
<ul>
<li>number &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>context</dfn> :CanvasRenderingContext2D</dt>
<dd>
<p>drawing context to use</p>
<details>



<h3>Returns</h3>
<ul>
<li>CanvasRenderingContext2D &#8211; </li>
</ul>






</details>
</dd>
<dt><dfn>mouseX</dfn> :number</dt>
<dd>
<p>Mouse x position on display.</p>
<details>



<h3>Returns</h3>
<ul>
<li>number &#8211; [read-only]</li>
</ul>






</details>
</dd>
<dt><dfn>mouseY</dfn> :number</dt>
<dd>
<p>Mouse y position on display.</p>
<details>



<h3>Returns</h3>
<ul>
<li>number &#8211; [read-only]</li>
</ul>






</details>
</dd>
<dt><dfn>alpha</dfn> :number</dt>
<dd>
<p></p>
<details>



<h3>Returns</h3>
<ul>
<li>number &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>backgroundColor</dfn> :Color</dt>
<dd>
<p></p>
<details>



<h3>Returns</h3>
<ul>
<li>Color &#8211; </li>
</ul>






</details>
</dd>
<dt><dfn>backgroundImage</dfn> :HTMLImageElement</dt>
<dd>
<p></p>
<details>



<h3>Returns</h3>
<ul>
<li>HTMLImageElement &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>backgroundRepeat</dfn> :string</dt>
<dd>
<p></p>
<details>



<h3>Returns</h3>
<ul>
<li>string &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
<li>SyntaxError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>children</dfn> :Array</dt>
<dd>
<p></p>
<details>



<h3>Returns</h3>
<ul>
<li>Array &#8211; </li>
</ul>






</details>
</dd>
<dt><dfn>clearBitmap</dfn> :boolean</dt>
<dd>
<p></p>
<details>



<h3>Returns</h3>
<ul>
<li>boolean &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>element</dfn> :HTMLElement</dt>
<dd>
<p></p>
<details>



<h3>Returns</h3>
<ul>
<li>HTMLElement &#8211; </li>
</ul>






</details>
</dd>
<dt><dfn>id</dfn> :string</dt>
<dd>
<p></p>
<details>



<h3>Returns</h3>
<ul>
<li>string &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>rotation</dfn> :number</dt>
<dd>
<p></p>
<details>



<h3>Returns</h3>
<ul>
<li>number &#8211; </li>
</ul>






</details>
</dd>
<dt><dfn>transform</dfn> :Matrix</dt>
<dd>
<p></p>
<details>



<h3>Returns</h3>
<ul>
<li>Matrix &#8211; </li>
</ul>






</details>
</dd>
<dt><dfn>visible</dfn> :boolean</dt>
<dd>
<p></p>
<details>



<h3>Returns</h3>
<ul>
<li>boolean &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>x</dfn> :number</dt>
<dd>
<p></p>
<details>



<h3>Returns</h3>
<ul>
<li>number &#8211; </li>
</ul>






</details>
</dd>
<dt><dfn>y</dfn> :number</dt>
<dd>
<p></p>
<details>



<h3>Returns</h3>
<ul>
<li>number &#8211; </li>
</ul>






</details>
</dd>
<dt><dfn>debug.stats</dfn> :Stats|boolean</dt>
<dd>
<p>Overlay a stats meter on the display. See http://github.com/mrdoob/stats.js for more info. To include in a compiled build, use ./build/make-doodle -S</p>
<details>



<h3>Returns</h3>
<ul>
<li>Stats|boolean &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>toString</dfn> :string</dt>
<dd>
<p>Returns the string representation of the specified object.</p>
<details>



<h3>Returns</h3>
<ul>
<li>string &#8211; </li>
</ul>






</details>
</dd>
</section>
<section>
<h2>Methods</h2>
<dl>
<dt><dfn>addChildAt</dfn> (layer:Layer, index:number) :Layer</dt>
<dd>
<p>Add a layer to the display's children at the given array position. Layer inherits the dimensions of the display.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>layer:Layer &#8211;  </li>
<li>index:number &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>Layer &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>createLayer</dfn> () :Layer</dt>
<dd>
<p>Add a new layer to the display's children.</p>
<details>



<h3>Returns</h3>
<ul>
<li>Layer &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>on</dfn> (type:string, listener:Function) :void</dt>
<dd>
<p>Adds an event listener on an Emitter object. This is convenience alias for Emitter.addListener(type, listener, useCapture=false).</p>
<details>

<h3>Parameters</h3>
<ol>
<li>type:string &#8211;  </li>
<li>listener:Function &#8211;  </li>
</ol>



<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>once</dfn> (type:string, listener:Function) :void</dt>
<dd>
<p>Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>type:string &#8211;  </li>
<li>listener:Function &#8211;  </li>
</ol>



<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>appendTo</dfn> () :Node</dt>
<dd>
<p>Adds this node to the given node's children.</p>
<details>



<h3>Returns</h3>
<ul>
<li>Node &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>layers</dfn> () :array</dt>
<dd>
<p>Alias for display.children, since every child is a Layer.</p>
<details>



<h3>Returns</h3>
<ul>
<li>array &#8211; </li>
</ul>






</details>
</dd>
<dt><dfn>setChildIndex</dfn> (child:Node, index:number) :void</dt>
<dd>
<p>Changes the position of an existing child in the node's children array. This affects the layering of child objects.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>child:Node &#8211;  </li>
<li>index:number &#8211;  </li>
</ol>



<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>swapChildrenAt</dfn> (idx1:number, idx2:number) :void</dt>
<dd>
<p>Change the display order of two child layers at the given index.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>idx1:number &#8211;  </li>
<li>idx2:number &#8211;  </li>
</ol>



<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>willTrigger</dfn> (type:string) :boolean</dt>
<dd>
<p>Checks whether an event listener is registered with this Emitter object or any of its ancestors for the specified event type. The difference between the hasListener() and the willTrigger() methods is that hasListener() examines only the object to which it belongs, whereas the willTrigger() method examines the entire event flow for the event specified by the type parameter.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>type:string &#8211;  The type of event.</li>
</ol>

<h3>Returns</h3>
<ul>
<li>boolean &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>hasListener</dfn> (type:string) :boolean</dt>
<dd>
<p>Checks whether the Emitter object has any listeners registered for a specific type of event.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>type:string &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>boolean &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>contains</dfn> (node:Node) :boolean</dt>
<dd>
<p>Determine if node is among it's children, grandchildren, etc.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>node:Node &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>boolean &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>emit</dfn> (event:doodle.events.Event) :boolean</dt>
<dd>
<p>Dispatches an event into the event flow. The event target is the Emitter object upon which the emit() method is called.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>event:doodle.events.Event &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>boolean &#8211; true if the event was successfully dispatched.</li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>broadcast</dfn> (event:doodle.events.Event) :boolean</dt>
<dd>
<p>Dispatches an event to every object with an active listener. Ignores propagation path, objects come from</p>
<details>

<h3>Parameters</h3>
<ol>
<li>event:doodle.events.Event &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>boolean &#8211; True if the event was successfully dispatched.</li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
<li>Error &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>handleEvent</dfn> (event:doodle.events.Event) :boolean</dt>
<dd>
<p>Lookup and call listener if registered for specific event type.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>event:doodle.events.Event &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>boolean &#8211; true if node has listeners of event type.</li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>addChild</dfn> (node:Node) :Node</dt>
<dd>
<p></p>
<details>

<h3>Parameters</h3>
<ol>
<li>node:Node &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>Node &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>createNode</dfn> () :void</dt>
<dd>
<p></p>
<details>










</details>
</dd>
<dt><dfn>createSprite</dfn> () :void</dt>
<dd>
<p></p>
<details>










</details>
</dd>
<dt><dfn>getChildById</dfn> (id:string) :Node|undefined</dt>
<dd>
<p></p>
<details>

<h3>Parameters</h3>
<ol>
<li>id:string &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>Node|undefined &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>globalToLocal</dfn> (pt:Point) :Point</dt>
<dd>
<p></p>
<details>

<h3>Parameters</h3>
<ol>
<li>pt:Point &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>Point &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>localToGlobal</dfn> (pt:Point) :Point</dt>
<dd>
<p></p>
<details>

<h3>Parameters</h3>
<ol>
<li>pt:Point &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>Point &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>removeAllChildren</dfn> () :void</dt>
<dd>
<p></p>
<details>





<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>removeChildById</dfn> (id:string) :Node</dt>
<dd>
<p></p>
<details>

<h3>Parameters</h3>
<ol>
<li>id:string &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>Node &#8211; Removed child node.</li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>removeChild</dfn> (node:Node) :Node</dt>
<dd>
<p></p>
<details>

<h3>Parameters</h3>
<ol>
<li>node:Node &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>Node &#8211; Removed child node.</li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
<li>ReferenceError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>rotate</dfn> (deg:number) :number</dt>
<dd>
<p></p>
<details>

<h3>Parameters</h3>
<ol>
<li>deg:number &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>number &#8211; </li>
</ul>






</details>
</dd>
<dt><dfn>scaleX</dfn> (sx:number) :number</dt>
<dd>
<p></p>
<details>

<h3>Parameters</h3>
<ol>
<li>sx:number &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>number &#8211; </li>
</ul>






</details>
</dd>
<dt><dfn>scaleY</dfn> (sy:number) :number</dt>
<dd>
<p></p>
<details>

<h3>Parameters</h3>
<ol>
<li>sy:number &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>number &#8211; </li>
</ul>






</details>
</dd>
<dt><dfn>swapChildren</dfn> (node1:Node, node2:Node) :void</dt>
<dd>
<p></p>
<details>

<h3>Parameters</h3>
<ol>
<li>node1:Node &#8211;  </li>
<li>node2:Node &#8211;  </li>
</ol>



<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>addListener</dfn> (type:string, listener:Function) :void</dt>
<dd>
<p>Registers an event listener object with an Emitter object so that the listener receives notification of an event.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>type:string &#8211;  </li>
<li>listener:Function &#8211;  </li>
</ol>



<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>removeChildAt</dfn> (index:number) :void</dt>
<dd>
<p>Remove a layer from the display's children at the given array position.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>index:number &#8211;  </li>
</ol>



<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>removeLayer</dfn> (id:string) :void</dt>
<dd>
<p>Remove a layer with a given name from the display's children.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>id:string &#8211;  </li>
</ol>



<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>removeListener</dfn> (type:string, listener:Function) :void</dt>
<dd>
<p>Removes a listener from the Emitter object.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>type:string &#8211;  </li>
<li>listener:Function &#8211;  </li>
</ol>



<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>removeAllListeners</dfn> (type:string) :void</dt>
<dd>
<p>Removes all listeners from the Emitter for the specified event.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>type:string &#8211;  </li>
</ol>



<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>getNodesUnderPoint</dfn> (point:Point) :Array</dt>
<dd>
<p>Returns a list of nodes under a given display position.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>point:Point &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>Array &#8211; </li>
</ul>

<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>listeners</dfn> (type:string) :array</dt>
<dd>
<p>Returns an array of listeners for the specified event.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>type:string &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>array &#8211; </li>
</ul>






</details>
</dd>
<dt><dfn>swapDepthAt</dfn> (index:number) :void</dt>
<dd>
<p>Swap positions with another node at a given index in the parents child list.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>index:number &#8211;  </li>
</ol>



<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
<li>RangeError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>swapDepths</dfn> (node:Node) :void</dt>
<dd>
<p>Swap positions with a sibling node.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>node:Node &#8211;  </li>
</ol>



<h3>Throws</h3>
<ul>
<li>TypeError &#8211; </li>
<li>ReferenceError &#8211; </li>
</ul>




</details>
</dd>
<dt><dfn>getBounds</dfn> (targetCoordSpace:Node) :Rectangle|null</dt>
<dd>
<p>The bounding box of a Node is a union of all it's child Sprite's bounds.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>targetCoordSpace:Node &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>Rectangle|null &#8211; </li>
</ul>






</details>
</dd>
</section>
<section>
<h2>Class Functions</h2>
<dl>
<dt><dfn>isDisplay</dfn> (obj:Object) :boolean</dt>
<dd>
<p>Test if an object is a Display.</p>
<details>

<h3>Parameters</h3>
<ol>
<li>obj:Object &#8211;  </li>
</ol>

<h3>Returns</h3>
<ul>
<li>boolean &#8211; True if object is a Doodle Display.</li>
</ul>






</details>
</dd>
</section>
</div>
<footer>
<a href="http://github.com/billyist/doodle-js/blob/master/BSD-LICENSE.txt">Copyright</a> <a href="http://www.lamberta.org">Billy Lamberta</a>
</footer>
</body>
</html>
